/**
 * Sentinel 4.5 Automated Vulnerability Scanner
 * 
 * This module implements automated scanning of the application code, dependencies,
 * and configurations to detect known security vulnerabilities.
 */

import { logSecurityEvent, logAuditEvent } from './audit-log';
import { sendAlert, AlertSeverity, AlertType } from './alert-system';
import { createSecurityIncident, IncidentType } from './incident-response';
import { getSecuritySettings } from './config';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';

const execAsync = promisify(exec);

// Vulnerability types
export enum VulnerabilityType {
  DEPENDENCY = 'dependency',
  CODE = 'code',
  CONFIGURATION = 'configuration',
  SERVER = 'server',
  LIBRARY = 'library',
  PROTOCOL = 'protocol'
}

// Vulnerability severity levels
export enum VulnerabilitySeverity {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  INFO = 'info'
}

// Vulnerability status
export enum VulnerabilityStatus {
  OPEN = 'open',
  FIXED = 'fixed',
  MITIGATED = 'mitigated',
  ACCEPTED = 'accepted',
  FALSE_POSITIVE = 'false_positive'
}

// Vulnerability data
export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  type: VulnerabilityType;
  severity: VulnerabilitySeverity;
  cveId?: string;
  cvssScore?: number;
  packageName?: string;
  packageVersion?: string;
  fixedVersion?: string;
  file?: string;
  line?: number;
  code?: string;
  recommendation: string;
  references: string[];
  discoveredAt: number;
  status: VulnerabilityStatus;
  assignedTo?: string;
  resolvedBy?: string;
  resolvedAt?: number;
  notes?: string[];
  scanId: string;
}

// Scan result
export interface ScanResult {
  id: string;
  startTime: number;
  endTime: number;
  status: 'completed' | 'failed' | 'in-progress';
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  vulnerabilities: Vulnerability[];
  error?: string;
  scannedComponents: {
    dependencies: boolean;
    code: boolean;
    configurations: boolean;
    server: boolean;
  };
}

// Store scan results
const scanResults: Map<string, ScanResult> = new Map();

// Store vulnerabilities
const vulnerabilities: Map<string, Vulnerability> = new Map();

// Default scan configuration
const DEFAULT_SCAN_CONFIG = {
  scanDependencies: true,
  scanCode: true,
  scanConfigurations: true,
  scanServer: true,
  scanFrequency: 7 * 24 * 60 * 60 * 1000, // Weekly
  autoFix: false,
  alertOnHighSeverity: true,
  createIncidents: true
};

// Last scan time
let lastScanTime = 0;

/**
 * Initialize vulnerability scanner
 */
export function initVulnerabilityScanner(): void {
  // Schedule regular scans
  const checkAndScanIfNeeded = async () => {
    const settings = getSecuritySettings();
    const scanConfig = {
      ...DEFAULT_SCAN_CONFIG,
      ...(settings.vulnerabilityScanConfig || {})
    };
    
    const now = Date.now();
    if (now - lastScanTime >= scanConfig.scanFrequency) {
      await runSecurityScan();
    }
  };
  
  // Run initial check
  setTimeout(() => {
    checkAndScanIfNeeded();
  }, 5 * 60 * 1000); // Wait 5 minutes after startup
  
  // Schedule regular checks
  setInterval(() => {
    checkAndScanIfNeeded();
  }, 12 * 60 * 60 * 1000); // Check every 12 hours
  
  console.log('Vulnerability Scanner module initialized');
}

/**
 * Run a comprehensive security scan
 */
export async function runSecurityScan(
  options: {
    scanDependencies?: boolean;
    scanCode?: boolean;
    scanConfigurations?: boolean;
    scanServer?: boolean;
    runById?: string;
  } = {}
): Promise<ScanResult> {
  // Get settings
  const settings = getSecuritySettings();
  const scanConfig = {
    ...DEFAULT_SCAN_CONFIG,
    ...(settings.vulnerabilityScanConfig || {}),
    ...options
  };
  
  // Generate scan ID
  const scanId = `scan-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  const startTime = Date.now();
  
  // Create initial scan result
  const scanResult: ScanResult = {
    id: scanId,
    startTime,
    endTime: 0,
    status: 'in-progress',
    summary: {
      total: 0,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    },
    vulnerabilities: [],
    scannedComponents: {
      dependencies: false,
      code: false,
      configurations: false,
      server: false
    }
  };
  
  // Store scan result
  scanResults.set(scanId, scanResult);
  
  // Log scan start
  logSecurityEvent(
    options.runById || 'system',
    'Security vulnerability scan started',
    {
      scanId,
      componentsToScan: {
        dependencies: scanConfig.scanDependencies,
        code: scanConfig.scanCode,
        configurations: scanConfig.scanConfigurations,
        server: scanConfig.scanServer
      }
    },
    'system'
  );
  
  try {
    // Initialize vulnerability list
    const discoveredVulnerabilities: Vulnerability[] = [];
    
    // Scan dependencies if enabled
    if (scanConfig.scanDependencies) {
      const dependencyVulnerabilities = await scanDependencies();
      discoveredVulnerabilities.push(...dependencyVulnerabilities);
      scanResult.scannedComponents.dependencies = true;
    }
    
    // Scan code if enabled
    if (scanConfig.scanCode) {
      const codeVulnerabilities = await scanCode();
      discoveredVulnerabilities.push(...codeVulnerabilities);
      scanResult.scannedComponents.code = true;
    }
    
    // Scan configurations if enabled
    if (scanConfig.scanConfigurations) {
      const configVulnerabilities = await scanConfigurations();
      discoveredVulnerabilities.push(...configVulnerabilities);
      scanResult.scannedComponents.configurations = true;
    }
    
    // Scan server if enabled
    if (scanConfig.scanServer) {
      const serverVulnerabilities = await scanServer();
      discoveredVulnerabilities.push(...serverVulnerabilities);
      scanResult.scannedComponents.server = true;
    }
    
    // Process discovered vulnerabilities
    for (const vulnerability of discoveredVulnerabilities) {
      // Add scan ID
      vulnerability.scanId = scanId;
      
      // Store vulnerability
      vulnerabilities.set(vulnerability.id, vulnerability);
      
      // Add to scan result
      scanResult.vulnerabilities.push(vulnerability);
      
      // Update summary
      scanResult.summary.total++;
      
      switch (vulnerability.severity) {
        case VulnerabilitySeverity.CRITICAL:
          scanResult.summary.critical++;
          break;
        case VulnerabilitySeverity.HIGH:
          scanResult.summary.high++;
          break;
        case VulnerabilitySeverity.MEDIUM:
          scanResult.summary.medium++;
          break;
        case VulnerabilitySeverity.LOW:
          scanResult.summary.low++;
          break;
        case VulnerabilitySeverity.INFO:
          scanResult.summary.info++;
          break;
      }
      
      // Create security alert for high severity vulnerabilities
      if (scanConfig.alertOnHighSeverity &&
          (vulnerability.severity === VulnerabilitySeverity.CRITICAL || 
           vulnerability.severity === VulnerabilitySeverity.HIGH)) {
        
        const alertSeverity = vulnerability.severity === VulnerabilitySeverity.CRITICAL ?
          AlertSeverity.CRITICAL :
          AlertSeverity.HIGH;
        
        sendAlert(
          alertSeverity,
          AlertType.SYSTEM,
          `${vulnerability.severity} vulnerability found: ${vulnerability.title}`,
          {
            vulnerabilityId: vulnerability.id,
            type: vulnerability.type,
            packageName: vulnerability.packageName,
            file: vulnerability.file,
            recommendation: vulnerability.recommendation
          }
        );
      }
      
      // Create security incident for critical vulnerabilities
      if (scanConfig.createIncidents && vulnerability.severity === VulnerabilitySeverity.CRITICAL) {
        createSecurityIncident(
          IncidentType.SYSTEM_MISCONFIGURATION,
          AlertSeverity.CRITICAL,
          `Critical vulnerability: ${vulnerability.title}`,
          {
            vulnerabilityId: vulnerability.id,
            type: vulnerability.type,
            packageName: vulnerability.packageName,
            file: vulnerability.file,
            recommendation: vulnerability.recommendation
          }
        );
      }
    }
    
    // Update scan status
    scanResult.status = 'completed';
    scanResult.endTime = Date.now();
    
    // Update last scan time
    lastScanTime = scanResult.endTime;
    
    // Update scan result
    scanResults.set(scanId, scanResult);
    
    // Log scan completion
    logSecurityEvent(
      options.runById || 'system',
      'Security vulnerability scan completed',
      {
        scanId,
        duration: (scanResult.endTime - scanResult.startTime) / 1000,
        vulnerabilitiesByType: countVulnerabilitiesByType(scanResult.vulnerabilities),
        summary: scanResult.summary
      },
      'system'
    );
    
    // Send summary alert for significant findings
    if (scanResult.summary.critical > 0 || scanResult.summary.high > 0) {
      sendAlert(
        scanResult.summary.critical > 0 ? AlertSeverity.CRITICAL : AlertSeverity.HIGH,
        AlertType.SYSTEM,
        `Security scan found ${scanResult.summary.critical} critical and ${scanResult.summary.high} high vulnerabilities`,
        {
          scanId,
          criticalCount: scanResult.summary.critical,
          highCount: scanResult.summary.high,
          mediumCount: scanResult.summary.medium,
          totalCount: scanResult.summary.total
        }
      );
    }
    
    return scanResult;
  } catch (error) {
    // Update scan status
    scanResult.status = 'failed';
    scanResult.endTime = Date.now();
    scanResult.error = error.message;
    
    // Update scan result
    scanResults.set(scanId, scanResult);
    
    // Log scan failure
    logSecurityEvent(
      options.runById || 'system',
      'Security vulnerability scan failed',
      {
        scanId,
        error: error.message,
        stack: error.stack
      },
      'system'
    );
    
    return scanResult;
  }
}

/**
 * Scan dependencies for vulnerabilities
 */
async function scanDependencies(): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    // Check if npm is available
    await execAsync('npm --version');
    
    // Run npm audit
    const { stdout } = await execAsync('npm audit --json');
    const auditResult = JSON.parse(stdout);
    
    // Process audit results
    if (auditResult.vulnerabilities) {
      for (const [packageName, vulnerability] of Object.entries(auditResult.vulnerabilities)) {
        const vuln = vulnerability as any;
        
        // Generate a unique ID
        const vulnId = `dep-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
        
        // Map severity
        let severity: VulnerabilitySeverity;
        switch (vuln.severity.toLowerCase()) {
          case 'critical':
            severity = VulnerabilitySeverity.CRITICAL;
            break;
          case 'high':
            severity = VulnerabilitySeverity.HIGH;
            break;
          case 'moderate':
            severity = VulnerabilitySeverity.MEDIUM;
            break;
          case 'low':
            severity = VulnerabilitySeverity.LOW;
            break;
          default:
            severity = VulnerabilitySeverity.INFO;
        }
        
        // Create vulnerability object
        vulnerabilities.push({
          id: vulnId,
          title: vuln.title || `Vulnerability in ${packageName}`,
          description: vuln.url ? `See ${vuln.url} for details` : 'No description available',
          type: VulnerabilityType.DEPENDENCY,
          severity,
          cveId: vuln.cves && vuln.cves.length > 0 ? vuln.cves[0] : undefined,
          cvssScore: vuln.cvss ? vuln.cvss.score : undefined,
          packageName,
          packageVersion: vuln.version,
          fixedVersion: vuln.fixAvailable ? vuln.fixAvailable.version : undefined,
          recommendation: vuln.fixAvailable
            ? `Update to version ${vuln.fixAvailable.version} or later`
            : 'No fix available yet, consider using an alternative package',
          references: vuln.url ? [vuln.url] : [],
          discoveredAt: Date.now(),
          status: VulnerabilityStatus.OPEN,
          scanId: ''
        });
      }
    }
  } catch (error) {
    console.error('Error scanning dependencies:', error);
    // Even if npm audit fails, try other dependency analysis methods
  }
  
  // If no vulnerabilities found or npm audit wasn't available,
  // we could implement alternative checks here
  
  return vulnerabilities;
}

/**
 * Scan code for security vulnerabilities
 */
async function scanCode(): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];
  
  // This is where you would integrate with tools like ESLint security plugin,
  // SonarQube, or other static analysis tools
  
  // For demonstration, we'll simulate finding some vulnerabilities
  // In a real implementation, you would parse the output of a real code scanning tool
  
  const simulatedVulnerabilities = [
    {
      id: `code-${Date.now()}-1`,
      title: 'Possible SQL Injection',
      description: 'Direct use of user input in SQL query without proper parameterization',
      type: VulnerabilityType.CODE,
      severity: VulnerabilitySeverity.HIGH,
      file: 'server/routes/user.js',
      line: 42,
      code: 'db.query(`SELECT * FROM users WHERE username = "${req.body.username}"`, ...)',
      recommendation: 'Use parameterized queries or an ORM to prevent SQL injection',
      references: [
        'https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html'
      ],
      discoveredAt: Date.now(),
      status: VulnerabilityStatus.OPEN,
      scanId: ''
    },
    {
      id: `code-${Date.now()}-2`,
      title: 'Insecure Random Number Generation',
      description: 'Using Math.random() for security-sensitive operations',
      type: VulnerabilityType.CODE,
      severity: VulnerabilitySeverity.MEDIUM,
      file: 'server/utils/token.js',
      line: 23,
      code: 'const token = Math.random().toString(36).substr(2);',
      recommendation: 'Use crypto.randomBytes() for generating secure random values',
      references: [
        'https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html'
      ],
      discoveredAt: Date.now(),
      status: VulnerabilityStatus.OPEN,
      scanId: ''
    }
  ];
  
  vulnerabilities.push(...simulatedVulnerabilities);
  
  return vulnerabilities;
}

/**
 * Scan configuration files for security issues
 */
async function scanConfigurations(): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];
  
  // This is where you would scan configuration files for security issues
  // For example, checking for missing HTTPS settings, improper CORS configuration, etc.
  
  // For demonstration, we'll simulate finding some vulnerabilities
  // In a real implementation, you would analyze actual configuration files
  
  const simulatedVulnerabilities = [
    {
      id: `config-${Date.now()}-1`,
      title: 'Missing Content Security Policy',
      description: 'No Content-Security-Policy header is configured',
      type: VulnerabilityType.CONFIGURATION,
      severity: VulnerabilitySeverity.MEDIUM,
      file: 'server/app.js',
      recommendation: 'Configure Content-Security-Policy header to restrict content sources',
      references: [
        'https://content-security-policy.com/',
        'https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP'
      ],
      discoveredAt: Date.now(),
      status: VulnerabilityStatus.OPEN,
      scanId: ''
    },
    {
      id: `config-${Date.now()}-2`,
      title: 'Insecure CORS Configuration',
      description: 'CORS is configured to allow all origins (*)',
      type: VulnerabilityType.CONFIGURATION,
      severity: VulnerabilitySeverity.HIGH,
      file: 'server/middlewares/cors.js',
      line: 5,
      code: 'origin: "*"',
      recommendation: 'Restrict CORS to specific trusted origins',
      references: [
        'https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS',
        'https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny'
      ],
      discoveredAt: Date.now(),
      status: VulnerabilityStatus.OPEN,
      scanId: ''
    }
  ];
  
  vulnerabilities.push(...simulatedVulnerabilities);
  
  return vulnerabilities;
}

/**
 * Scan server for security vulnerabilities
 */
async function scanServer(): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];
  
  // In a real implementation, you would scan the server environment
  // for misconfigurations, weak TLS, open ports, etc.
  
  // For demonstration, we'll simulate finding some vulnerabilities
  
  const simulatedVulnerabilities = [
    {
      id: `server-${Date.now()}-1`,
      title: 'TLS 1.0/1.1 Enabled',
      description: 'Server supports deprecated TLS versions 1.0 and 1.1',
      type: VulnerabilityType.SERVER,
      severity: VulnerabilitySeverity.MEDIUM,
      recommendation: 'Disable TLS 1.0 and 1.1, and only enable TLS 1.2 and 1.3',
      references: [
        'https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html'
      ],
      discoveredAt: Date.now(),
      status: VulnerabilityStatus.OPEN,
      scanId: ''
    }
  ];
  
  vulnerabilities.push(...simulatedVulnerabilities);
  
  return vulnerabilities;
}

/**
 * Get all scan results
 */
export function getAllScanResults(): ScanResult[] {
  return Array.from(scanResults.values());
}

/**
 * Get a specific scan result
 */
export function getScanResult(scanId: string): ScanResult | undefined {
  return scanResults.get(scanId);
}

/**
 * Get all vulnerabilities
 */
export function getAllVulnerabilities(
  filters?: {
    status?: VulnerabilityStatus;
    severity?: VulnerabilitySeverity;
    type?: VulnerabilityType;
  }
): Vulnerability[] {
  let result = Array.from(vulnerabilities.values());
  
  // Apply filters if provided
  if (filters) {
    if (filters.status) {
      result = result.filter(v => v.status === filters.status);
    }
    
    if (filters.severity) {
      result = result.filter(v => v.severity === filters.severity);
    }
    
    if (filters.type) {
      result = result.filter(v => v.type === filters.type);
    }
  }
  
  return result;
}

/**
 * Get a specific vulnerability
 */
export function getVulnerability(id: string): Vulnerability | undefined {
  return vulnerabilities.get(id);
}

/**
 * Update vulnerability status
 */
export function updateVulnerabilityStatus(
  id: string,
  status: VulnerabilityStatus,
  updatedBy: string,
  notes?: string
): boolean {
  const vulnerability = vulnerabilities.get(id);
  if (!vulnerability) return false;
  
  // If status is changing to resolved states, set resolvedBy and resolvedAt
  if (
    (status === VulnerabilityStatus.FIXED ||
     status === VulnerabilityStatus.MITIGATED ||
     status === VulnerabilityStatus.ACCEPTED ||
     status === VulnerabilityStatus.FALSE_POSITIVE) &&
    vulnerability.status !== status
  ) {
    vulnerability.resolvedBy = updatedBy;
    vulnerability.resolvedAt = Date.now();
  }
  
  // Update status
  vulnerability.status = status;
  
  // Add notes if provided
  if (notes) {
    if (!vulnerability.notes) vulnerability.notes = [];
    vulnerability.notes.push(`[${new Date().toISOString()}] [${updatedBy}] ${notes}`);
  }
  
  // Update vulnerability
  vulnerabilities.set(id, vulnerability);
  
  // Log the update
  logAuditEvent(
    updatedBy,
    'Vulnerability status updated',
    {
      vulnerabilityId: id,
      newStatus: status,
      notes
    },
    'system'
  );
  
  return true;
}

/**
 * Assign vulnerability to a user
 */
export function assignVulnerability(
  id: string,
  assignedTo: string,
  assignedBy: string,
  notes?: string
): boolean {
  const vulnerability = vulnerabilities.get(id);
  if (!vulnerability) return false;
  
  // Update assignee
  vulnerability.assignedTo = assignedTo;
  
  // Add notes if provided
  if (notes) {
    if (!vulnerability.notes) vulnerability.notes = [];
    vulnerability.notes.push(`[${new Date().toISOString()}] [${assignedBy}] Assigned to ${assignedTo}: ${notes}`);
  }
  
  // Update vulnerability
  vulnerabilities.set(id, vulnerability);
  
  // Log the assignment
  logAuditEvent(
    assignedBy,
    'Vulnerability assigned',
    {
      vulnerabilityId: id,
      assignedTo,
      notes
    },
    'system'
  );
  
  return true;
}

/**
 * Count vulnerabilities by type
 */
function countVulnerabilitiesByType(vulnerabilities: Vulnerability[]): Record<string, number> {
  const counts: Record<string, number> = {};
  
  for (const vulnerability of vulnerabilities) {
    if (!counts[vulnerability.type]) {
      counts[vulnerability.type] = 0;
    }
    
    counts[vulnerability.type]++;
  }
  
  return counts;
}