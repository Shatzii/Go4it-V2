import * as fs from 'fs/promises';
import * as path from 'path';
import { storage } from '../storage';

// Define base directory for files
const BASE_DIR = path.resolve(process.cwd(), './rhythm-pages');

// Ensure base directory exists
async function ensureBaseDir() {
  try {
    await fs.access(BASE_DIR);
  } catch (error) {
    // Create the directory if it doesn't exist
    await fs.mkdir(BASE_DIR, { recursive: true });
    
    // Create some initial files
    const initialFiles = [
      { 
        path: 'index.rhy', 
        content: '@extends("layout/page.rhy")\n\n@section("title") Home @endsection\n\n@section("content")\n  <h1>Welcome to Rhythm</h1>\n  <p>This is a sample page generated by Rhythm Engine.</p>\n@endsection'
      },
      {
        path: 'layout/page.rhy',
        content: '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>@yield("title") | Rhythm</title>\n  <link rel="stylesheet" href="/assets/css/main.css">\n</head>\n<body>\n  <header>\n    <h1>Rhythm</h1>\n    <nav>\n      <ul>\n        <li><a href="/">Home</a></li>\n        <li><a href="/about">About</a></li>\n      </ul>\n    </nav>\n  </header>\n  <main>\n    @yield("content")\n  </main>\n  <footer>\n    <p>&copy; 2023 Rhythm</p>\n  </footer>\n</body>\n</html>'
      }
    ];
    
    for (const file of initialFiles) {
      const filePath = path.join(BASE_DIR, file.path);
      const dirPath = path.dirname(filePath);
      
      // Ensure directory exists
      await fs.mkdir(dirPath, { recursive: true });
      
      // Write file
      await fs.writeFile(filePath, file.content);
    }
  }
}

// Initialize the file system
ensureBaseDir().catch(console.error);

// File service implementation
class FileService {
  // Get the file tree
  async getFileTree() {
    await ensureBaseDir();
    
    async function buildTree(dir: string): Promise<any> {
      const fullPath = path.join(BASE_DIR, dir);
      const relativePath = dir || '/';
      const name = path.basename(dir) || 'rhythm-pages';
      
      const stat = await fs.stat(fullPath);
      
      if (stat.isFile()) {
        return {
          name,
          path: relativePath,
          type: 'file'
        };
      }
      
      const entries = await fs.readdir(fullPath);
      const children = [];
      
      for (const entry of entries) {
        const childPath = path.join(dir, entry);
        const child = await buildTree(childPath);
        children.push(child);
      }
      
      // Sort children: directories first, then files, both alphabetically
      children.sort((a, b) => {
        if (a.type === b.type) {
          return a.name.localeCompare(b.name);
        }
        return a.type === 'directory' ? -1 : 1;
      });
      
      return {
        name,
        path: relativePath,
        type: 'directory',
        children
      };
    }
    
    return buildTree('');
  }
  
  // Get file content
  async getFileContent(filePath: string) {
    const fullPath = path.join(BASE_DIR, filePath);
    
    try {
      const content = await fs.readFile(fullPath, 'utf-8');
      const stat = await fs.stat(fullPath);
      
      return {
        content,
        path: filePath,
        lastModified: stat.mtime.toISOString()
      };
    } catch (error) {
      throw new Error(`Failed to read file: ${filePath}`);
    }
  }
  
  // Save file
  async saveFile(filePath: string, content: string) {
    const fullPath = path.join(BASE_DIR, filePath);
    const dirPath = path.dirname(fullPath);
    
    try {
      // Ensure directory exists
      await fs.mkdir(dirPath, { recursive: true });
      
      // Write file
      await fs.writeFile(fullPath, content);
      
      // Log activity
      await storage.logActivity({
        path: filePath,
        prompt: `Updated file: ${filePath}`,
        time: new Date().toISOString()
      });
      
      return true;
    } catch (error) {
      throw new Error(`Failed to save file: ${filePath}`);
    }
  }
  
  // Create file or directory
  async createFile(filePath: string, type: 'file' | 'directory' = 'file') {
    const fullPath = path.join(BASE_DIR, filePath);
    const dirPath = path.dirname(fullPath);
    
    try {
      // Ensure parent directory exists
      await fs.mkdir(dirPath, { recursive: true });
      
      if (type === 'directory') {
        // Create directory
        await fs.mkdir(fullPath, { recursive: true });
      } else {
        // Create empty file if it doesn't exist
        try {
          await fs.access(fullPath);
          throw new Error(`File already exists: ${filePath}`);
        } catch (error) {
          // File doesn't exist, create it
          await fs.writeFile(fullPath, '');
        }
      }
      
      // Log activity
      await storage.logActivity({
        path: filePath,
        prompt: `Created ${type}: ${filePath}`,
        time: new Date().toISOString()
      });
      
      return true;
    } catch (error) {
      throw new Error(`Failed to create ${type}: ${filePath}`);
    }
  }
  
  // Delete file or directory
  async deleteFile(filePath: string) {
    const fullPath = path.join(BASE_DIR, filePath);
    
    try {
      const stat = await fs.stat(fullPath);
      
      if (stat.isDirectory()) {
        // Delete directory recursively
        await fs.rm(fullPath, { recursive: true });
      } else {
        // Delete file
        await fs.unlink(fullPath);
      }
      
      // Log activity
      await storage.logActivity({
        path: filePath,
        prompt: `Deleted: ${filePath}`,
        time: new Date().toISOString()
      });
      
      return true;
    } catch (error) {
      throw new Error(`Failed to delete: ${filePath}`);
    }
  }
  
  // Rename file or directory
  async renameFile(oldPath: string, newPath: string) {
    const fullOldPath = path.join(BASE_DIR, oldPath);
    const fullNewPath = path.join(BASE_DIR, newPath);
    const newDirPath = path.dirname(fullNewPath);
    
    try {
      // Ensure new parent directory exists
      await fs.mkdir(newDirPath, { recursive: true });
      
      // Rename file or directory
      await fs.rename(fullOldPath, fullNewPath);
      
      // Log activity
      await storage.logActivity({
        path: newPath,
        prompt: `Renamed: ${oldPath} to ${newPath}`,
        time: new Date().toISOString()
      });
      
      return true;
    } catch (error) {
      throw new Error(`Failed to rename: ${oldPath} to ${newPath}`);
    }
  }
}

export const fileService = new FileService();
